{"version":3,"sources":["jquery.readingtime.js","jquery.smoothState.js","site/_init.js"],"names":["$","fn","readingtime","options","settings","extend","wpm","round","words","trim","this","first","text","split","length","Math","jQuery","window","document","undefined","history","pushState","smoothState","$body","consl","console","defaults","debug","anchors","forms","blacklist","prefetch","cacheLength","loadingClass","alterRequest","request","onBefore","$currentTarget","$container","onStart","duration","render","onProgress","onReady","$newContent","html","onAfter","utility","isExternal","url","match","toLowerCase","location","protocol","replace","RegExp","http:","https:","host","stripHash","href","isHash","prev","hasHash","indexOf","samePath","translate","dataType","type","shouldLoadAnchor","$anchor","prop","is","clearIfOverCapacity","cache","cap","Object","keys","obj","k","prototype","hasOwnProperty","call","push","storePageIn","object","doc","id","$newDoc","status","title","filter","triggerAllAnimationEndEvent","$element","resetOn","animationCount","animationstart","animationend","eventname","onAnimationStart","e","delegateTarget","stopPropagation","onAnimationEnd","trigger","on","redraw","height","onPopState","state","$page","page","data","load","Smoothstate","element","elementId","targetHash","isTransitioning","currentHref","clear","fetch","callback","noop","ajaxRequest","ajax","success","error","complete","repositionWindow","$targetHashEl","newPosition","offset","top","body","scrollTop","updateContent","containerId","removeClass","one","setTimeout","warn","hasRunCallback","callbBackEnded","responses","loaded","eventName","fetching","addClass","log","hoverAnchor","event","currentTarget","clickAnchor","metaKey","ctrlKey","preventDefault","submitForm","$form","serialize","bindEventHandlers","restartCSSAnimations","classes","replaceState","documentElement","outerHTML","declaresmoothState","each","tagname","tagName","onpopstate","smoothStateUtility","_init","jqueryReadingTime","$articles","index","el","$article","$etr","siblings","find","etr","msg","etrText","config","$content","animate","contentLoaded"],"mappings":"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","file":"main.js","sourcesContent":["(function($) {\n  $.fn.readingtime = function(options) {\n\n    var settings = $.extend({\n      wpm:    250,\n      round:  'round'\n    }, options);\n\n    var words = $.trim(this.first().text()).split(/\\s+/).length;\n    return Math[settings.round](words/settings.wpm);\n  };\n}(jQuery));","/**\n * smoothState.js is a jQuery plugin to stop page load jank.\n *\n * This jQuery plugin progressively enhances page loads to\n * behave more like a single-page application.\n *\n * @author  Miguel Ángel Pérez   reachme@miguel-perez.com\n * @see     https://github.com/miguel-perez/jquery.smoothState.js\n *\n */\n\n;(function ( $, window, document, undefined ) {\n  'use strict';\n\n  /** Abort if browser does not support pushState */\n  if(!window.history.pushState) {\n    // setup a dummy fn, but don't intercept on link clicks\n    $.fn.smoothState = function() { return this; };\n    $.fn.smoothState.options = {};\n    return;\n  }\n\n  /** Abort if smoothState is already present **/\n  if($.fn.smoothState) { return; }\n\n  var\n    /** Used later to scroll page to the top */\n    $body = $('html, body'),\n\n    /** Used in debug mode to console out useful warnings */\n    consl = window.console,\n\n    /** Plugin default options, will be exposed as $fn.smoothState.options */\n    defaults = {\n\n      /** If set to true, smoothState will log useful debug information instead of aborting */\n      debug: false,\n\n      /** jQuery selector to specify which anchors smoothState should bind to */\n      anchors: 'a',\n\n      /** jQuery selector to specify which forms smoothState should bind to */\n      forms: 'form',\n\n      /** A selector that defines what should be ignored by smoothState */\n      blacklist: '.no-smoothState',\n\n      /** If set to true, smoothState will prefetch a link's contents on hover */\n      prefetch: false,\n\n      /** The number of pages smoothState will try to store in memory */\n      cacheLength: 0,\n\n      /** Class that will be applied to the body while the page is loading */\n      loadingClass: 'is-loading',\n\n      /**\n       * A function that can be used to alter the ajax request settings before it is called\n       * @param  {Object} request jQuery.ajax settings object that will be used to make the request\n       * @return {Object}         Altered request object\n       */\n      alterRequest: function (request) {\n        return request;\n      },\n\n      /** Run before a page load has been activated */\n      onBefore: function ($currentTarget, $container) {},\n\n      /** Run when a page load has been activated */\n      onStart: {\n        duration: 0,\n        render: function ($container) {}\n      },\n\n      /** Run if the page request is still pending and onStart has finished animating */\n      onProgress: {\n        duration: 0,\n        render: function ($container) {}\n      },\n\n      /** Run when requested content is ready to be injected into the page  */\n      onReady: {\n        duration: 0,\n        render: function ($container, $newContent) {\n          $container.html($newContent);\n        }\n      },\n\n      /** Run when content has been injected and all animations are complete  */\n      onAfter: function($container, $newContent) {}\n    },\n\n    /** Utility functions that are decoupled from smoothState */\n    utility = {\n\n      /**\n       * Checks to see if the url is external\n       * @param   {string}    url - url being evaluated\n       * @see     http://stackoverflow.com/questions/6238351/fastest-way-to-detect-external-urls\n       *\n       */\n      isExternal: function (url) {\n        var match = url.match(/^([^:\\/?#]+:)?(?:\\/\\/([^\\/?#]*))?([^?#]+)?(\\?[^#]*)?(#.*)?/);\n        if (typeof match[1] === 'string' && match[1].length > 0 && match[1].toLowerCase() !== window.location.protocol) {\n          return true;\n        }\n        if (typeof match[2] === 'string' &&\n          match[2].length > 0 &&\n          match[2].replace(new RegExp(':(' + {'http:': 80, 'https:': 443}[window.location.protocol] +\n            ')?$'), '') !== window.location.host) {\n          return true;\n        }\n        return false;\n      },\n\n      /**\n       * Strips the hash from a url and returns the new href\n       * @param   {string}    href - url being evaluated\n       *\n       */\n      stripHash: function(href) {\n        return href.replace(/#.*/, '');\n      },\n\n      /**\n       * Checks to see if the url is an internal hash\n       * @param   {string}    href - url being evaluated\n       * @param   {string}    prev - previous url (optional)\n       *\n       */\n      isHash: function (href, prev) {\n        prev = prev || window.location.href;\n\n        var hasHash = (href.indexOf('#') > -1) ? true : false,\n            samePath = (utility.stripHash(href) === utility.stripHash(prev)) ? true : false;\n\n        return (hasHash && samePath);\n      },\n\n      /**\n       * Translates a url string into a $.ajax settings obj\n       * @param  {Object|String} request url or settings obj\n       * @return {Object}        settings object\n       */\n      translate: function(request) {\n          var defaults = {\n            dataType: 'html',\n            type: 'GET'\n          };\n          if(typeof request === 'string') {\n            request = $.extend({}, defaults, { url: request });\n          } else {\n            request = $.extend({}, defaults, request);\n          }\n          return request;\n      },\n\n      /**\n       * Checks to see if we should be loading this URL\n       * @param   {string}    url - url being evaluated\n       * @param   {string}    blacklist - jquery selector\n       *\n       */\n      shouldLoadAnchor: function ($anchor, blacklist) {\n        var href = $anchor.prop('href');\n        // URL will only be loaded if it's not an external link, hash, or blacklisted\n        return (!utility.isExternal(href) && !utility.isHash(href) && !$anchor.is(blacklist) && !$anchor.prop('target'));\n      },\n\n      /**\n       * Resets an object if it has too many properties\n       *\n       * This is used to clear the 'cache' object that stores\n       * all of the html. This would prevent the client from\n       * running out of memory and allow the user to hit the\n       * server for a fresh copy of the content.\n       *\n       * @param   {object}    obj\n       * @param   {number}    cap\n       *\n       */\n      clearIfOverCapacity: function (cache, cap) {\n        // Polyfill Object.keys if it doesn't exist\n        if (!Object.keys) {\n          Object.keys = function (obj) {\n            var keys = [],\n              k;\n            for (k in obj) {\n              if (Object.prototype.hasOwnProperty.call(obj, k)) {\n                keys.push(k);\n              }\n            }\n            return keys;\n          };\n        }\n\n        if (Object.keys(cache).length > cap) {\n          cache = {};\n        }\n\n        return cache;\n      },\n\n      /**\n       * Stores a document fragment into an object\n       * @param   {object}    object - object where it will be sotred\n       * @param   {string}    url - name of the entry\n       * @param   {string|document}    doc - entire html\n       * @param   {string}    id - the id of the fragment\n       *\n       */\n      storePageIn: function (object, url, doc, id) {\n        var $newDoc = $(doc);\n\n        object[url] = { // Content is indexed by the url\n          status: 'loaded',\n          // Stores the title of the page, .first() prevents getting svg titles\n          title: $newDoc.filter('title').first().text(),\n          html: $newDoc.filter('#' + id), // Stores the contents of the page\n        };\n        return object;\n      },\n\n      /**\n       * Triggers an 'allanimationend' event when all animations are complete\n       * @param   {object}    $element - jQuery object that should trigger event\n       * @param   {string}    resetOn - which other events to trigger allanimationend on\n       *\n       */\n      triggerAllAnimationEndEvent: function ($element, resetOn) {\n\n        resetOn = ' ' + resetOn || '';\n\n        var animationCount = 0,\n          animationstart = 'animationstart webkitAnimationStart oanimationstart MSAnimationStart',\n          animationend = 'animationend webkitAnimationEnd oanimationend MSAnimationEnd',\n          eventname = 'allanimationend',\n          onAnimationStart = function (e) {\n            if ($(e.delegateTarget).is($element)) {\n              e.stopPropagation();\n              animationCount++;\n            }\n          },\n          onAnimationEnd = function (e) {\n            if ($(e.delegateTarget).is($element)) {\n              e.stopPropagation();\n              animationCount--;\n              if(animationCount === 0) {\n                $element.trigger(eventname);\n              }\n            }\n          };\n\n        $element.on(animationstart, onAnimationStart);\n        $element.on(animationend, onAnimationEnd);\n\n        $element.on('allanimationend' + resetOn, function(){\n          animationCount = 0;\n          utility.redraw($element);\n        });\n      },\n\n      /** Forces browser to redraw elements */\n      redraw: function ($element) {\n        $element.height();\n      }\n    },\n\n    /** Handles the popstate event, like when the user hits 'back' */\n    onPopState = function ( e ) {\n      if(e.state !== null) {\n        var url = window.location.href,\n          $page = $('#' + e.state.id),\n          page = $page.data('smoothState');\n\n        if(page.href !== url && !utility.isHash(url, page.href)) {\n          page.load(url, false);\n        }\n      }\n    },\n\n    /** Constructor function */\n    Smoothstate = function ( element, options ) {\n      var\n        /** Container element smoothState is run on */\n        $container = $(element),\n\n        /** ID of the main container */\n        elementId = $container.prop('id'),\n\n        /** If a hash was clicked, we'll store it here so we\n         *  can scroll to it once the new page has been fully\n         *  loaded.\n         */\n        targetHash = null,\n\n        /** Used to prevent fetching while we transition so\n         *  that we don't mistakenly override a cache entry\n         *  we need.\n         */\n        isTransitioning = false,\n\n        /** Variable that stores pages after they are requested */\n        cache = {},\n\n        /** Url of the content that is currently displayed */\n        currentHref = window.location.href,\n\n        /**\n         * Clears a given page from the cache, if no url is provided\n         * it will clear the entire cache.\n         * @param  {String} url entry that is to be deleted.\n         */\n        clear = function(url) {\n          url = url || false;\n          if(url && cache.hasOwnProperty(url)) {\n            delete cache[url];\n          } else {\n            cache = {};\n          }\n          $container.data('smoothState').cache = cache;\n        },\n\n        /**\n         * Fetches the contents of a url and stores it in the 'cache' variable\n         * @param  {String|Object}   request  url or request settings object\n         * @param  {Function} callback function that will run as soon as it finishes\n         */\n        fetch = function (request, callback) {\n\n          // Sets a default in case a callback is not defined\n          callback = callback || $.noop;\n\n          // Allows us to accept a url string or object as the ajax settings\n          var settings = utility.translate(request);\n\n          // Don't prefetch if we have the content already or if it's a form\n          if(cache.hasOwnProperty(settings.url) && typeof settings.data === 'undefined') {\n            return;\n          }\n\n          // Check the length of the cache and clear it if needed\n          cache = utility.clearIfOverCapacity(cache, options.cacheLength);\n\n          // Let other parts of the code know we're working on getting the content\n          cache[settings.url] = { status: 'fetching' };\n\n          // Make the ajax request\n          var ajaxRequest = $.ajax(settings);\n\n          // Store contents in cache variable if successful\n          ajaxRequest.success(function (html) {\n            utility.storePageIn(cache, settings.url, html, elementId);\n            $container.data('smoothState').cache = cache;\n          });\n\n          // Mark as error to be acted on later\n          ajaxRequest.error(function () {\n            cache[settings.url].status = 'error';\n          });\n\n          // Call fetch callback\n          if(callback) {\n            ajaxRequest.complete(callback);\n          }\n        },\n\n        repositionWindow = function(){\n          // Scroll to a hash anchor on destination page\n          if(targetHash) {\n            var $targetHashEl = $(targetHash, $container);\n            if($targetHashEl.length){\n              var newPosition = $targetHashEl.offset().top;\n              document.body.scrollTop = newPosition;\n            }\n            targetHash = null;\n          }\n        },\n\n        /** Updates the contents from cache[url] */\n        updateContent = function (url) {\n          // If the content has been requested and is done:\n          var containerId = '#' + elementId,\n              $newContent = cache[url] ? $(cache[url].html.html()) : null;\n\n          if($newContent.length) {\n\n            // Update the title\n            document.title = cache[url].title;\n\n            // Update current url\n            $container.data('smoothState').href = url;\n\n            // Remove loading class\n            if(options.loadingClass) {\n              $body.removeClass(options.loadingClass);\n            }\n\n            // Call the onReady callback and set delay\n            options.onReady.render($container, $newContent);\n\n            $container.one('ss.onReadyEnd', function(){\n\n              // Allow prefetches to be made again\n              isTransitioning = false;\n\n              // Run callback\n              options.onAfter($container, $newContent);\n\n              repositionWindow();\n\n            });\n\n            window.setTimeout(function(){\n              $container.trigger('ss.onReadyEnd');\n            }, options.onReady.duration);\n\n          } else if (!$newContent && options.debug && consl) {\n            // Throw warning to help debug in debug mode\n            consl.warn('No element with an id of ' + containerId + ' in response from ' + url + ' in ' + cache);\n          } else {\n            // No content availble to update with, aborting...\n            window.location = url;\n          }\n        },\n\n        /**\n         * Loads the contents of a url into our container\n         * @param   {string}    url\n         * @param   {bool}      push - used to determine if we should\n         *                      add a new item into the history object\n         */\n        load = function (request, push) {\n\n          var settings = utility.translate(request);\n\n          /** Makes this an optional variable by setting a default */\n          if(typeof push === 'undefined') {\n            push = true;\n          }\n\n          var\n            /** Used to check if the onProgress function has been run */\n            hasRunCallback = false,\n\n            callbBackEnded = false,\n\n            /** List of responses for the states of the page request */\n            responses = {\n\n              /** Page is ready, update the content */\n              loaded: function () {\n                var eventName = hasRunCallback ? 'ss.onProgressEnd' : 'ss.onStartEnd';\n\n                if(!callbBackEnded || !hasRunCallback) {\n                  $container.one(eventName, function(){\n                    updateContent(settings.url);\n                  });\n                } else if(callbBackEnded) {\n                  updateContent(settings.url);\n                }\n\n                if(push) {\n                  window.history.pushState({ id: elementId }, cache[settings.url].title, settings.url);\n                }\n              },\n\n              /** Loading, wait 10 ms and check again */\n              fetching: function () {\n\n                if(!hasRunCallback) {\n\n                  hasRunCallback = true;\n\n                  // Run the onProgress callback and set trigger\n                  $container.one('ss.onStartEnd', function(){\n\n                    // Add loading class\n                    if(options.loadingClass) {\n                      $body.addClass(options.loadingClass);\n                    }\n\n                    options.onProgress.render($container);\n\n                    window.setTimeout(function (){\n                      $container.trigger('ss.onProgressEnd');\n                      callbBackEnded = true;\n                    }, options.onProgress.duration);\n\n                  });\n                }\n\n                window.setTimeout(function () {\n                  // Might of been canceled, better check!\n                  if(cache.hasOwnProperty(settings.url)){\n                    responses[cache[settings.url].status]();\n                  }\n                }, 10);\n              },\n\n              /** Error, abort and redirect */\n              error: function (){\n                if(options.debug && consl) {\n                  consl.log('There was an error loading: ' + settings.url);\n                } else {\n                  window.location = settings.url;\n                }\n              }\n            };\n\n          if (!cache.hasOwnProperty(settings.url)) {\n            fetch(settings);\n          }\n\n          // Run the onStart callback and set trigger\n          options.onStart.render($container);\n\n          window.setTimeout(function(){\n            $body.scrollTop(0);\n            $container.trigger('ss.onStartEnd');\n          }, options.onStart.duration);\n\n          // Start checking for the status of content\n          responses[cache[settings.url].status]();\n        },\n\n        /**\n         * Binds to the hover event of a link, used for prefetching content\n         * @param   {object}    event\n         */\n        hoverAnchor = function (event) {\n          var request,\n              $anchor = $(event.currentTarget);\n\n          if (utility.shouldLoadAnchor($anchor, options.blacklist) && !isTransitioning) {\n            event.stopPropagation();\n            request = utility.translate($anchor.prop('href'));\n            request = options.alterRequest(request);\n            fetch(request);\n          }\n        },\n\n        /**\n         * Binds to the click event of a link, used to show the content\n         * @param   {object}    event\n         */\n        clickAnchor = function (event) {\n          var $anchor = $(event.currentTarget);\n\n          // Ctrl (or Cmd) + click must open a new tab\n          if (!event.metaKey && !event.ctrlKey && utility.shouldLoadAnchor($anchor, options.blacklist)) {\n            var request = utility.translate($anchor.prop('href'));\n\n            // stopPropagation so that event doesn't fire on parent containers.\n            isTransitioning = true;\n            event.stopPropagation();\n            event.preventDefault();\n            targetHash = $anchor.prop('hash');\n\n            // Allows modifications to the request\n            request = options.alterRequest(request);\n\n            options.onBefore($anchor, $container);\n\n            load(request);\n          }\n        },\n\n        /**\n         * Binds to form submissions\n         * @param  {Event} event\n         */\n        submitForm = function (event) {\n          var $form = $(event.currentTarget);\n\n          if(!$form.is(options.blacklist)){\n            event.preventDefault();\n            event.stopPropagation();\n\n            var request = {\n                  url: $form.prop('action'),\n                  data: $form.serialize(),\n                  type: $form.prop('method')\n                };\n\n            isTransitioning = true;\n\n            request = options.alterRequest(request);\n\n            if(request.type.toLowerCase() === 'get') {\n              request.url = request.url + '?' + request.data;\n            }\n\n            // Call the onReady callback and set delay\n            options.onBefore($form, $container);\n\n            load(request);\n          }\n        },\n\n        /**\n         * Binds all events and inits functionality\n         * @param   {object}    event\n         */\n        bindEventHandlers = function ($element) {\n\n          $element.on('click', options.anchors, clickAnchor);\n\n          $element.on('submit', options.forms, submitForm);\n\n          if (options.prefetch) {\n            $element.on('mouseover touchstart', options.anchors, hoverAnchor);\n          }\n        },\n\n        /** Restart the container's css animations */\n        restartCSSAnimations = function () {\n          var classes = $container.prop('class');\n          $container.removeClass(classes);\n          utility.redraw($container);\n          $container.addClass(classes);\n        };\n\n      /** Merge defaults and global options into current configuration */\n      options = $.extend( {}, $.fn.smoothState.options, options );\n\n      /** Sets a default state */\n      if(window.history.state === null) {\n        window.history.replaceState({ id: elementId }, document.title, currentHref);\n      }\n\n      /** Stores the current page in cache variable */\n      utility.storePageIn(cache, currentHref, document.documentElement.outerHTML, elementId);\n\n      /** Bind all of the event handlers on the container, not anchors */\n      utility.triggerAllAnimationEndEvent($container, 'ss.onStartEnd ss.onProgressEnd ss.onEndEnd');\n\n      /** Bind all of the event handlers on the container, not anchors */\n      bindEventHandlers($container);\n\n      /** Public methods */\n      return {\n        href: currentHref,\n        cache: cache,\n        clear: clear,\n        load: load,\n        fetch: fetch,\n        restartCSSAnimations: restartCSSAnimations\n      };\n    },\n\n    /** Returns elements with smoothState attached to it */\n    declaresmoothState = function ( options ) {\n      return this.each(function () {\n        var tagname = this.tagName.toLowerCase();\n        // Checks to make sure the smoothState element has an id and isn't already bound\n        if(this.id && tagname !== 'body' && tagname !== 'html' && !$.data(this, 'smoothState')) {\n          // Makes public methods available via $('element').data('smoothState');\n          $.data(this, 'smoothState', new Smoothstate(this, options));\n        } else if (!this.id && consl) {\n          // Throw warning if in debug mode\n          consl.warn('Every smoothState container needs an id but the following one does not have one:', this);\n        } else if ((tagname === 'body' || tagname === 'html') && consl) {\n          // We dont support making th html or the body element the smoothstate container\n          consl.warn('The smoothstate container cannot be the ' + this.tagName + ' tag');\n        }\n      });\n    };\n\n  /** Sets the popstate function */\n  window.onpopstate = onPopState;\n\n  /** Makes utility functions public for unit tests */\n  $.smoothStateUtility = utility;\n\n  /** Defines the smoothState plugin */\n  $.fn.smoothState = declaresmoothState;\n\n  /* expose the default options */\n  $.fn.smoothState.options = defaults;\n\n})(jQuery, window, document);\n","jQuery( function( $ ) {\n\tvar _init = {};\n\n\t/**\n\t * Initializes the jQuery Reading Time plugin.\n\t *\n\t * @return  {Boolean}  false\n\t */\n\t_init.jqueryReadingTime = function() {\n\t\t// Make sure the jQuery Reading Time plugin exists.\n\t\tif ( typeof $.fn.readingtime !== 'function' ) {\n\t\t\treturn;\n\t\t} // if()\n\n\t\t// Make sue we have some articles to work with.\n\t\tvar $articles = $( '.post-content' );\n\t\tif ( $articles.length === 0 ) {\n\t\t\treturn false;\n\t\t} // if()\n\n\t\t$articles.each( function( index, el ) {\n\t\t\tvar $article = $( el ),\n\t\t\t\t\t$etr     = $article.siblings( '.post-header' ).find( '.etr' ),\n\t\t\t\t\tetr      = $article.readingtime()\n\t\t\t;\n\n\t\t\t// Make sure the etr element exists.\n\t\t\tif ( $etr.length === 0 ) {\n\t\t\t\t$etr = $article.siblings( '.etr' );\n\t\t\t\tif ( $etr.length === 0 ) {\n\t\t\t\t\treturn;\n\t\t\t\t} // if()\n\t\t\t} // if()\n\n\t\t\t// Get the message to append after the time.\n\t\t\tvar msg = $etr.data( 'msg' );\n\t\t\tmsg = ( typeof msg === 'undefined' ) ? '' : msg;\n\n\t\t\t// Add the estimate time to read text.\n\t\t\tvar etrText = etr + ' ' + msg;\n\t\t\t$etr.text( etrText.trim() );\n\t\t} );\n\n\t\treturn false;\n\t}; // _init.jqueryReadingTime()\n\n\t/**\n\t * Inializes smoothstate.js jQuery library\n\t *\n\t * @see https://github.com/miguel-perez/smoothState.js\n\t *\n\t * @return  {Boolean}  False\n\t */\n\t_init.smoothState = function() {\n\t\t// Make sure jQuery.smoothState exists.\n\t\tif ( typeof $.fn.smoothState !== 'function' ) {\n\t\t\treturn false;\n\t\t} // if()\n\n\t\tvar $body  = $( 'html, body' ),\n\t\t\t\tconfig = {},\n\t\t\t\t$content = $( '#page_content' )\n\t\t;\n\n\t\t// Make sure the content wrapper exists.\n\t\tif ( $content.length === 0 ) {\n\t\t\treturn false;\n\t\t} // if()\n\n\t\t// Before content is retrieved.\n\t\tconfig.onStart = {\n\t\t\tduration: 0,\n\t\t\trender  : function() {\n\t\t\t\t$content.addClass( 'is-exiting' );\n\n\t\t\t\t$body.animate( { scrollTop: 0 } );\n\t\t\t},\n\t\t};\n\n\t\t// When content is ready to be loaded.\n\t\tconfig.onReady = {\n\t\t\tduration : 0,\n\t\t\trender   : function( $container, $newContent ) {\n\t\t\t\t// Remove your CSS animation reversing class\n\t\t\t\t$content.removeClass( 'is-exiting' );\n\n\t\t\t\t// Inject the new content\n\t\t\t\t$container.html( $newContent );\n\t\t\t}\n\t\t};\n\n\t\t// After content has loaded.\n\t\tconfig.onAfter = function() {\n\t\t\t_init.contentLoaded();\n\t\t};\n\n\t\t// Inialize smoothstate.js.\n\t\t$content.smoothState( config ).data( 'smoothState' );\n\n\t\treturn false;\n\t}; // _init.smoothState()\n\n\t_init.contentLoaded = function() {\n\t\t_init.jqueryReadingTime();\n\t\treturn false;\n\t};\n\n\t// Initialize All The Things!!!!\n\t_init.contentLoaded();\n\t_init.smoothState();\n}( jQuery ) );\n"],"sourceRoot":"/source/"}